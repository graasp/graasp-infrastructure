name: Auto-start dev infra
on:
  schedule:
    - cron: "30 7 * * *"
  # allow to start infra of another env manually
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        type: environment
        required: true

permissions:
  id-token: write # This is required for requesting the JWT
  contents: read # This is required for actions/checkout

jobs:
  deploy:
    name: "Deploy infra in running state to ${{ inputs.environment || 'dev' }} environment"
    environment: ${{ inputs.environment || 'dev' }}
    env:
      state: "running"
      environment: ${{ inputs.environment || 'dev' }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        id: configure-aws
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.TF_AWS_ROLE_ARN }}
          role-session-name: GitHub_Action_deploy_infrastructure
          aws-region: ${{ vars.AWS_REGION }}

      - name: Start DB
        if: ${{ env.state != 'stopped' }}
        run: |
          # start the db if it is in a "stopped" state
          if [ $(aws rds describe-db-instances | jq ".DBInstances.[0].DBInstanceStatus") == "stopped" ]
          then
            aws rds start-db-instance --db-instance-identifier graasp-${{ env.environment }}
          fi
          while [ $(aws rds describe-db-instances | jq -r ".DBInstances.[0].DBInstanceStatus") != "available" ]
          do
            echo "waiting for DB to be up $(date -u +%H:%M:%S) (UTC)"
            sleep 30
          done
          echo "DB successfully started!"

      - name: Stop DB
        if: ${{ env.state == 'stopped' }}
        run: |
          # stop the db if it is in the "available" state
          if [ $(aws rds describe-db-instances | jq ".DBInstances.[0].DBInstanceStatus") == "available" ]
          then
            aws rds stop-db-instance --db-instance-identifier graasp-${{ env.environment }}
          fi
          while [ $(aws rds describe-db-instances | jq -r ".DBInstances.[0].DBInstanceStatus") != "stopped" ]
          do
            echo "waiting for DB to be down $(date -u +%H:%M:%S) (UTC)"
            sleep 30
          done
          echo "DB successfully stopped!"

      - name: Prepare terraform
        uses: ./.github/actions/prepare-terraform
        with:
          aws-region: ${{ vars.AWS_REGION }}
          aws-access-key-id: ${{ secrets.TF_AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.TF_SECRET_AWS_ACCESS_KEY }}

      - name: Deploy
        run: npx cdktf deploy --auto-approve 'graasp-${{ env.environment }}'
        shell: bash
        env:
          INFRA_STATE: ${{ env.state }}
          MAINTENANCE_HEADER_NAME: ${{ secrets.MAINTENANCE_HEADER_NAME }}
          MAINTENANCE_HEADER_SECRET: ${{ secrets.MAINTENANCE_HEADER_SECRET }}
          TF_VAR_MEILISEARCH_MASTER_KEY: ${{ secrets.TF_MEILISEARCH_MASTER_KEY }}
          TF_VAR_GRAASP_DB_PASSWORD: ${{ secrets.TF_GRAASP_DB_PASSWORD }}
          TF_VAR_ETHERPAD_DB_PASSWORD: ${{ secrets.TF_ETHERPAD_DB_PASSWORD }}
          TF_VAR_UMAMI_DB_PASSWORD: ${{ secrets.TF_VAR_UMAMI_DB_PASSWORD }}
          TF_VAR_GRAASP_DB_GATEKEEPER_KEY_NAME: ${{ secrets.TF_GRAASP_DB_GATEKEEPER_KEY_NAME }}
          TF_VAR_DB_GATEKEEPER_AMI_ID: ${{ vars.TF_DB_GATEKEEPER_AMI_ID }}
          TF_VAR_DB_GATEKEEPER_INSTANCE_TYPE: ${{ vars.TF_DB_GATEKEEPER_INSTANCE_TYPE }}
