name: Composite terraform CDK deploy workflow
description: Deploy the infrastructure in a specific state

inputs:
  state:
    description: "Infra state"
    required: true
  environment:
    description: "Environment to target"
    required: true
  aws-role-to-assume:
    description: "AWS Role to assume to start/stop the DB"
    required: true
  aws-region:
    description: "AWS Region for for the deployment"
    required: true
  aws-access-key-id:
    description: "AWS Key id"
    required: true
  aws-secret-access-key:
    description: "AWS secret key"
    required: true

runs:
  using: composite
  steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS Credentials to assume terraform Role
      id: configure-aws-assume-role
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.aws-role-to-assume }}
        role-session-name: GitHub_Action_deploy_infrastructure
        aws-region: ${{ inputs.aws-region }}

    - name: Start DB
      if: ${{ inputs.state != 'stopped' }}
      shell: bash
      run: |
        # start the db if it is in a "stopped" state
        if [ $(aws rds describe-db-instances | jq ".DBInstances.[0].DBInstanceStatus") == "stopped" ]
        then
          aws rds start-db-instance --db-instance-identifier graasp-${{ inputs.environment }}
        fi
        while [ $(aws rds describe-db-instances | jq -r ".DBInstances.[0].DBInstanceStatus") != "available" ]
        do
          echo "waiting for DB to be up $(date -u +%H:%M:%S) (UTC)"
          sleep 30
        done
        echo "DB successfully started!"

    - name: Stop DB
      if: ${{ inputs.state == 'stopped' }}
      shell: bash
      run: |
        # stop the db if it is in the "available" state
        if [ $(aws rds describe-db-instances | jq ".DBInstances.[0].DBInstanceStatus") == "available" ]
        then
          aws rds stop-db-instance --db-instance-identifier graasp-${{ inputs.environment }}
        fi
        while [ $(aws rds describe-db-instances | jq -r ".DBInstances.[0].DBInstanceStatus") != "stopped" ]
        do
          echo "waiting for DB to be down $(date -u +%H:%M:%S) (UTC)"
          sleep 30
        done
        echo "DB successfully stopped!"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Setup Node
      uses: actions/setup-node@v4
      with:
        node-version: "22"

    - name: Install dependencies
      run: yarn install
      shell: bash

    - name: Generate module and provider bindings
      run: npx cdktf get
      shell: bash

    - name: Configure AWS Credentials for terraform user
      id: configure-aws-user
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ inputs.aws-access-key-id }}
        aws-secret-access-key: ${{ inputs.aws-secret-access-key }}
        aws-region: ${{ inputs.aws-region }}

    - name: Deploy Infra as "${{inputs.state }}" state to ${{ inputs.environment }} environment
      run: npx cdktf deploy --auto-approve 'graasp-${{ inputs.environment }}'
      shell: bash
      env:
        INFRA_STATE: ${{ inputs.state }}
        MAINTENANCE_HEADER_NAME: ${{ secrets.MAINTENANCE_HEADER_NAME }}
        MAINTENANCE_HEADER_SECRET: ${{ secrets.MAINTENANCE_HEADER_SECRET }}
        TF_VAR_MEILISEARCH_MASTER_KEY: ${{ secrets.TF_MEILISEARCH_MASTER_KEY }}
        TF_VAR_GRAASP_DB_PASSWORD: ${{ secrets.TF_GRAASP_DB_PASSWORD }}
        TF_VAR_ETHERPAD_DB_PASSWORD: ${{ secrets.TF_ETHERPAD_DB_PASSWORD }}
        TF_VAR_UMAMI_DB_PASSWORD: ${{ secrets.TF_VAR_UMAMI_DB_PASSWORD }}
        TF_VAR_GRAASP_DB_GATEKEEPER_KEY_NAME: ${{ secrets.TF_GRAASP_DB_GATEKEEPER_KEY_NAME }}
        TF_VAR_DB_GATEKEEPER_AMI_ID: ${{ vars.TF_DB_GATEKEEPER_AMI_ID }}
        TF_VAR_DB_GATEKEEPER_INSTANCE_TYPE: ${{ vars.TF_DB_GATEKEEPER_INSTANCE_TYPE }}
